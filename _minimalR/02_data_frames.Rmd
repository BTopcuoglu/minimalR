---
title: "Session 2"
output:
  html_document
---

## Learning goals

* Manipulate data frames
* Creating functions
* Incorporate metadata into scatter plots
* Read in data from various file formats


## Getting metadata into R
Metadata are the data about the data. For the dataset we worked with in the last section we might think about the people's diagnosis, BMI, race, smoking status, and so forth. This information is critical to understanding the structure in our data. I intimated this earlier, but we could imagine picking plotting symbols based on diagnosis or coloring our points based on the patient's sampling center or their BMI. Before we can do all these cool things, we need to learn how to work with our metadata.

For the data we used in the previous session, the researchers provided the metadata as a text file. In the world of R and programming, in general, text files are your friend. Files generated by Microsoft Excel or Word are not text files, but are rather a binary file format. For now, trust me that text is best. The `baxter.metadata.tsv` file is a tab-delineated file. This means that the columns are separated by tabs. Another common format is for columns to be comma-delineated. These are often called `tsv` and `csv` files, respectively. In the previous session you saw how we could read in the ordination data using the `read.table` command. There are many commands for reading in data from a file, but this one works pretty well for most purposes.

```{r}
metadata <- read.table(file="data/baxter.metadata.tsv", header=T, sep='\t', stringsAsFactors=FALSE)
```

Take a look at this command, what do you think is happening here? How do you think it would change if you had a `csv` instead? Our new `metadata` variable holds a `data.frame`. Previously we saw variables that were a `vector`. You can think of a `data.frame` as a collection of vectors that are all the same length but can each differ in the type of data they contain whether it is numerical, text, logical, or categorical data. A data.frame is very much like a spreadsheet - it is a table where the rows represent an entity and the columns represent its characteristics.

For you, this might beg the question, I have my metadata stored in a Microsoft Excel spreadsheet, how should I convert that to a text file? Previously we learned about DRY, another practice we want to develop is to leave raw data raw. All sorts of very bad things can happen when we start mucking with our raw data files. Once we've modified the metadata that our collaborators sent us we can't revert it to the original state very easily. So we can export a tsv or csv file from Excel or we can ask R to work directly with the Excel formatted file (`xlsx`). Here we'll introduce another great package - `openxlsx`

```{r, echo=FALSE, results=FALSE}
install.packages("openxlsx", repos="https://cloud.r-project.org/")
library("openxlsx")
```

```{r, eval=FALSE}
install.packages("openxlsx", repos="https://cloud.r-project.org/")
library("openxlsx")

metadata <- read.xlsx(file="data/baxter.metadata.xlsx")
```

Nuts. That didn't work. Hmmm. Let's get some help. If there's a function you want to use but don't know or can't remember it's arguments, you can type `?read.xlsx`. The `?` tells R you want help. In this case we get a screen that looks like so...

````
read.xlsx               package:openxlsx               R Documentation

Read data from a worksheet or Workbook object into a data.frame

Description:

     Read data from a worksheet or Workbook object into a data.frame

Usage:

     read.xlsx(xlsxFile, sheet = 1, startRow = 1, colNames = TRUE,
       skipEmptyRows = TRUE, rowNames = FALSE, detectDates = FALSE,
       rows = NULL, cols = NULL)

Arguments:

xlsxFile: An xlsx file or Workbook object

   sheet: The name or index of the sheet to read data from.

startRow: first row to begin looking for data.  Empty rows at the top
          of a file are always skipped, regardless of the value of
          startRow.

colNames: If ‘TRUE’, the first row of data will be used as column
          names.

skipEmptyRows: If ‘TRUE’, empty rows are skipped else empty rows after
          the first row containing data will return a row of NAs.

rowNames: If ‘TRUE’, first column of data will be used as row names.

detectDates: If ‘TRUE’, attempt to recognise dates and perform
          conversion.

    rows: A numeric vector specifying which rows in the Excel file to
          read. If NULL, all rows are read.

    cols: A numeric vector specifying which columns in the Excel file
          to read. If NULL, all columns are read.
````

Now we see the various arguments that `open.xlsx` will take. Instead of using the `file` argument, it wants us to use the `xlsxFile` argument. You can scroll down through the help page to get all sorts of useful information about the package including examples of how to use it. If you're running R from the command line, go ahead and hit `q` to return to the R prompt.

```{r}
metadata <- read.xlsx(xlsxFile="data/baxter.metadata.xlsx")
```

There you go, we now have our metadata in R. Let's see what we can do with it now.

### Activity 1
Open one of the spreadsheets where you keep the metadata for your project

* What do you see in your spreadsheet that might cause problems?
* How would you want to organize your metadata to make it easier to use with R?
* Look at the formatting of your data. Are all of the dates consistently formatted? Do you use a consistent capitalization style? Do you use non-text information (e.g. color) to represent values?


## Exploring our metadata
Let's dig into the Baxter data to think about how we'd like to use the metadata to improve our scatter plot. Whenever we read in a data frame there are a few things to do get a handle on your data. First, let's see how much data we have

```{r}
nrow(metadata)
ncol(metadata)
dim(metadata)
```

These three commands tell us the number of rows (`nrow`), columns (`ncol`), and both together (`dim`) in our metadata data frame. Let's find out the names of our columns

```{r}
colnames(metadata)
```

Are these column names informative? What type of information do you think each column might contain? If our data frame had names on the rows, we could get their value using the `rownames` command in a similar way. We can get a sense of the data frame using the `head` command, which returns the first 6 values of a variable or `tail`, which returns the last 6 values.

```{r}
head(metadata)
tail(metadata)
```

We can also use the `str` command to get an idea about the structure of a variable.

```{r}
str(metadata)
```

You'll commonly encounter numerical (`int` or `num`), categorical (`Factor`), boolean (`logical`), and text (`chr`) data. The `str` command will tell you the type of data you have in your variable.

Another function that is great for characterizing a data frame (or any type of variable) is `summary`. We used this previously on a vector, but when we use it on a data frame we get the summary output for each column.

```{r}
summary(metadata)
```

### Activity 2
What do you notice about the output of running `str(metadata)`? What types of data are there? Thinking about the list of data types outlined above, are there columns that are improperly formatted? Do the column names match the type of data in the column? Looking at the output of `summary(metadata)`, what do you notice about how the different data types were summarized?



## Working with metadata
After a quick look at the metadata we can see that there are a few things that aren't quite right that need to be fixed before we can use the metadata in our scatter plot: some of the columns are the wrong type and some of the values in the data frame don't make sense. Let's start by fixing the column types. To do this we'll have to figure out how to work with a single column in the data frame. We can pull out values of a data frame by several methods. The first we'll talk about is to retrieve columns using a `$`.

```{r}
metadata$sample
```

This is a `vector` of the subject sample ids. When we used the `str` function, what type of variable was this? Let's make it a `character` vector:

```{r}
metadata$sample <- as.character(metadata$sample)
summary(metadata)
str(metadata)
```

How has it changed? Let's use the `as.logical` function to change the `Hx_Prev` column:

```{r}
metadata$Hx_Prev <- as.logical(metadata$Hx_Prev)
summary(metadata)
str(metadata)
```

Another method of retrieving a column is to use square bracket notation

```{r}
metadata[, "Smoke"] <- as.logical(metadata[,"Smoke"])
summary(metadata)
str(metadata)
```

We can even mix and match them...

```{r}
metadata$Diabetic <- as.logical(metadata[,"Diabetic"])
summary(metadata)
str(metadata)
```

But that's probably an awful idea that we don't want to do too much because it will make our code hard to read.

### Activity 3
Go ahead and use the following lines of code to get you started in correcting the `Hx_Fam_CRC`, `NSAID`, `Diabetes_Med`, and `Hx_of_Polyps` columns.

```
metadata[, "Hx_Fam_CRC"] <- as.logical(metadata[,""])
metadata$ <- as.logical(metadata$NSAID)
metadata <- metadata
metadata <- metadata
```

<input type=button class=hideshow style="margin-bottom: 20px"></input>
<div style="display: none">

```{r}
metadata[, "Hx_Fam_CRC"] <- as.logical(metadata[,"Hx_Fam_CRC"])
metadata$NSAID <- as.logical(metadata$NSAID)
metadata$Diabetes_Med <- as.logical(metadata$Diabetes_Med)
metadata$Hx_of_Polyps <- as.logical(metadata$Hx_of_Polyps)
```

</div>



The final column of the data.frame, `stage` indicates the subject's cancer stage from 0 to 4. What type of variable does it currently use? What do you think it should be? Write the command below to make this happen.

<input type=button class=hideshow style="margin-bottom: 20px"></input>
<div style="display: none">

```{r}
metadata$stage <- as.factor(metadata$stage)
```

</div>

At this point, `str` and `summary` output should look like this:

```{r}
summary(metadata)
str(metadata)
```

So that's a good introduction on how to work with columns in a data frame. What about rows? Remember we can get someone's height by doing `metadata[, "Height"]`. Well we can also do this:

```{r}
metadata[,13]
```

Of course, it's a pain to keep track of the column number of variables we want to use and it's far easier to use the columns name. Well, we can use a number to retrieve a row...

```{r}
metadata[5,]
```

You can also name your rows and retrieve a row the same way that we did for the columns, but that can cause more problems than it solves, so we'll skip that for now.

We can also get a specific value from our data frame

```{r}
metadata[5, 'dx']
```

Rarely do we have needs that are so specific. We often want to manipulate values based on different criteria. We can use logical operations to get subsets of the data. Let's get all of the rows that are from women

```{r}
metadata[metadata$Gender == 'f',]
```

See what we did there? The `metadata$Gender == 'f'` creates a boolean vector of `TRUE` and `FALSE`. When we put this into the first spot of the bracket notation we get all the rows where the vector have a `TRUE`. What if we want all the subjects with an age 40 and under?

```{r}
metadata[metadata$Age <= 40,]
```

We can use the `nrow` function to see how many people are 40 and under...

```{r}
nrow(metadata[metadata$Age <= 40,])
```

We can also chain together conditions to get something more complex...

```{r}
metadata[metadata$Age <= 40 & metadata$Gender == 'm',]
metadata[metadata$Dx_Bin == "High Risk Normal" | is.na(metadata$Diabetic),]
```


### Activity 4
* Create a data frame that contains only individuals from Dana Farber

<input type=button class=hideshow style="margin-bottom: 20px"></input>
<div style="display: none">

```{r}
dana_farber <- metadata[metadata$Site == "Dana Farber",]
```

</div>

* Create a data frame that contains individuals that have a FIT result greater than 100

<input type=button class=hideshow style="margin-bottom: 20px"></input>
<div style="display: none">

```{r}
high_fit <- metadata[metadata$fit_result > 100,]
```

</div>

* Create a data frame that contains individuals are 50 years old and younger

<input type=button class=hideshow style="margin-bottom: 20px"></input>
<div style="display: none">

```{r}
fifty_and_under <- metadata[metadata$Age <= 50,]
```

</div>


You perhaps noticed that the minimum height and weight were 0.00. We can safely assume that these are missing data. In R, missing data are denoted by `NA`,  which is itself a special value. Let's change these values to `NA`. I'll show you how to do it for the Height column, you do it for the Weight column.

```
metadata[metadata$Height == 0 & !is.na(metadata$Height), "Height"] <- NA
metadata[metadata$ == 0 & !is.na(metadata$Weight), ""] <- NA

summary(metadata)
```

<input type=button class=hideshow style="margin-bottom: 20px"></input>
<div style="display: none">

```{r}
metadata[metadata$Height == 0 & !is.na(metadata$Height), "Height"] <- NA
metadata[metadata$Weight == 0 & !is.na(metadata$Weight), "Weight"] <- NA

summary(metadata)
```
</div>

Viola! There's more we could do to make the metadata file easier to work with, but for now let's move on and plot some data.


## Visualizing metadata in a scatter plot
We've covered a lot in this session, but before we go, let's put it all together and make a plot. Let's take our scatter plot and see if we can't add the patients' diagnosis. Here's one of the plots we had from the previous session.

```{r}
pcoa <- read.table(file="data/baxter.thetayc.pcoa.axes", header=T)

plot(x=pcoa$axis1, y=pcoa$axis2, xlab="PCo Axis 1", ylab="PCo Axis 2",
			xlim=c(-0.5, 0.5), ylim=c(-0.6, 0.4), pch=21, col="black", bg="red",
			lwd=1, cex=1, main="PCoA of ThetaYC Distances Between Stool Samples")
```

What argument do we want to change to use a different color? Plotting symbol? Let's start with the color. First, we'll create a variable that we'll call `dx_color`

```{r}
dx_color <- c(normal="black", adenoma="blue", cancer="red")
```

This should look familiar. We saw the `c( ... )` notation earlier. Now we have put names onto our values. What does the `dx_color` vector look like? What happens if you call `dx_color[2]`? How about `dx_color["carcinoma"]`? Cool eh? In our `metadata` data frame we have a column called `dx` that contains each patients diagnosis. What does `dx_color[metadata$dx]` do? See where we're going with this?

```{r}
plot(x=pcoa$axis1, y=pcoa$axis2, xlab="PCo Axis 1", ylab="PCo Axis 2",
			xlim=c(-0.5, 0.5), ylim=c(-0.6, 0.4), pch=21, col="black",
			bg=dx_color[metadata$dx], lwd=1, cex=1,
			main="PCoA of ThetaYC Distances Between Stool Samples")
```

### Activity 5
* Change the plotting symbols to use a different plotting symbol for each diagnosis.

<input type=button class=hideshow style="margin-bottom: 20px"></input>
<div style="display: none">
```{r}
dx_pch <- c(normal=17, adenoma=18, cancer=19)

plot(x=pcoa$axis1, y=pcoa$axis2, xlab="PCo Axis 1", ylab="PCo Axis 2",
		 xlim=c(-0.5, 0.5), ylim=c(-0.6, 0.4), pch=dx_pch[metadata$dx],
		 col=dx_color[metadata$dx], lwd=1, cex=1,
		 main="PCoA of ThetaYC Distances Between Stool Samples")
```
</div>

* Color the points for the male and female patients separately

<input type=button class=hideshow style="margin-bottom: 20px"></input>
<div style="display: none">
```{r}
sex_color <- c(f="red", m="blue")

plot(x=pcoa$axis1, y=pcoa$axis2, xlab="PCo Axis 1", ylab="PCo Axis 2",
		 xlim=c(-0.5, 0.5), ylim=c(-0.6, 0.4), pch=dx_pch[metadata$dx],
		 col=sex_color[metadata$Gender], lwd=1, cex=1,
		 main="PCoA of ThetaYC Distances Between Stool Samples")
```
</div>

* Create a color and symbol scheme of your own choosing


### Activity 6
At the end of the last session, you thought about scatter plots that you would use in your own research. You made a freehand sketch of what the plot would look like. The final question in that activity was, "What more do you need to learn to make the plot for your own data?" Update your list of things you need to learn. Are you ready to make your plot?

<script>
$( "input.hideshow" ).each( function ( index, button ) {
  button.value = 'Show an answer';
  $( button ).click( function () {
    var target = this.nextSibling ? this : this.parentNode;
    target = target.nextSibling.nextSibling;
    if ( target.style.display == 'block' || target.style.display == '' ) {
      target.style.display = 'none';
      this.value = 'Show an answer';
    } else {
      target.style.display = 'block';
      this.value = 'Hide answer';
    }
  } );
} );
</script>
